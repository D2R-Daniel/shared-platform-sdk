# Quickstart: Shared Platform Foundation Integration Guide

**Feature**: Shared Platform Foundation
**Date**: 2026-02-07
**Audience**: Product developers integrating the 5 `@dream/*` foundation packages
**Prerequisites**: Next.js 14+, React 18+, TypeScript 5+, PostgreSQL

---

## 1. Installation

Install all 5 foundation packages in one command:

```bash
npm install @dream/types @dream/auth @dream/rbac @dream/multi-tenant @dream/errors
```

Peer dependencies (already present in all 5 products):

```bash
npm install next-auth@5 zod
```

---

## 2. Package-by-Package Integration

Integrate in this order. Each step builds on the previous one.

---

### Step 1: @dream/types -- Shared Type Definitions

This package is the source of truth for every entity type across the platform. It replaces the 5 separate, incompatible type definitions currently spread across products.

#### Barrel import (most common)

```typescript
import type {
  User,
  Organization,
  Role,
  Team,
  Session,
  AuditEvent,
  Invitation,
  ApiResponse,
  ApiErrorResponse,
  PaginatedResponse,
} from '@dream/types';
```

#### Sub-module imports (for smaller bundles)

```typescript
// Auth-related types only
import type { Session, SessionUser, JWTPayload } from '@dream/types/auth';

// Team and department types only
import type { Team, TeamMember, Department } from '@dream/types/teams';

// Permission types only
import type { Permission, PermissionString } from '@dream/types/permissions';
```

#### Zod schemas for runtime validation

```typescript
import {
  userSchema,
  organizationSchema,
  roleSchema,
  teamSchema,
  invitationSchema,
  auditEventSchema,
} from '@dream/types/schemas';

// Validate incoming data at system boundaries
const result = userSchema.safeParse(incomingData);
if (!result.success) {
  console.error(result.error.flatten());
}
```

#### ORM-specific imports

Drizzle products (Dream Payroll, Dream Books, Dream Learn):

```typescript
import { usersTable, organizationsTable, rolesTable, teamsTable } from '@dream/types/drizzle';
```

Prisma products (Dream Team, HireWise):

```typescript
import { UserModel, OrganizationModel, RoleModel } from '@dream/types/prisma';
```

No ORM migration required. Both sub-paths export schemas compatible with your existing setup.

---

### Step 2: @dream/errors -- Standardized Error Handling

This package replaces the 5 different error formats currently in use (structured objects in Payroll, raw strings in Books and HireWise, mixed formats in Team and Learn).

#### Throw typed errors

```typescript
import {
  NotFoundError,
  ValidationError,
  AuthenticationError,
  AuthorizationError,
  ConflictError,
  RateLimitError,
  ServerError,
} from '@dream/errors';

// 404 -- resource not found
throw new NotFoundError({
  code: 'users/not-found',
  message: `User ${id} does not exist in tenant ${tenantId}`,
  userMessage: 'The requested user could not be found.',
});

// 400 -- validation failure
throw new ValidationError({
  code: 'users/invalid-email',
  message: 'Email field failed RFC 5322 validation',
  userMessage: 'Please enter a valid email address.',
  param: 'email',
});

// 409 -- conflict
throw new ConflictError({
  code: 'users/email-taken',
  message: `Email ${email} already registered`,
  userMessage: 'An account with this email already exists.',
});
```

#### Every error response follows the same shape

All products, all routes, all error types produce this format:

```json
{
  "success": false,
  "error": {
    "code": "users/not-found",
    "message": "User usr_abc123 does not exist in tenant tnt_xyz",
    "userMessage": "The requested user could not be found.",
    "requestId": "req_7f3a2b1c-4d5e-6f7a-8b9c-0d1e2f3a4b5c"
  }
}
```

The `requestId` is auto-generated by `createApiHandler` (Step 5 below). The `message` field is for developers and logs. The `userMessage` field is safe to display in the UI.

#### Error class to HTTP status mapping

| Error Class | HTTP Status | Use When |
|---|---|---|
| `ValidationError` | 400 | Invalid input data |
| `AuthenticationError` | 401 | Missing or invalid credentials |
| `AuthorizationError` | 403 | Valid credentials, insufficient permissions |
| `NotFoundError` | 404 | Resource does not exist (in this tenant) |
| `ConflictError` | 409 | Duplicate key, state conflict |
| `RateLimitError` | 429 | Too many requests |
| `ServerError` | 500 | Unexpected internal failure |

---

### Step 3: @dream/auth -- Authentication

This package wraps NextAuth v5 with shared defaults: 8-hour sessions, account lockout, SSO auto-provisioning, and auth-by-default middleware.

#### 3a. Create auth configuration

Create `lib/auth/config.ts`:

```typescript
import { createAuthConfig } from '@dream/auth';

export const authConfig = createAuthConfig({
  providers: ['credentials', 'azure-entra'],

  azure: {
    clientId: process.env.AZURE_AD_CLIENT_ID!,
    clientSecret: process.env.AZURE_AD_CLIENT_SECRET!,
    tenantId: process.env.AZURE_AD_TENANT_ID!,
  },

  // 8-hour session duration (foundation default, shown here for clarity)
  sessionMaxAge: 28800,

  // Account lockout after 5 consecutive failures
  lockout: {
    maxAttempts: 5,
    durationMinutes: 15,
  },

  // Routes that skip authentication (everything else requires auth by default)
  publicRoutes: [
    '/auth/signin',
    '/auth/signup',
    '/auth/error',
    '/api/health',
  ],

  // Optional callbacks for product-specific behavior
  callbacks: {
    enrichJwt: async (token, user, account) => {
      // Add product-specific claims to the JWT
      // Example: Dream Team adds employeeId
      return token;
    },
  },
});
```

#### 3b. Create middleware

Create or replace `middleware.ts` in the project root:

```typescript
import { createAuthMiddleware } from '@dream/auth';
import { authConfig } from '@/lib/auth/config';

export default createAuthMiddleware(authConfig);

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
};
```

This replaces the manual session checks in every route. All routes are protected by default. Only routes listed in `publicRoutes` are accessible without authentication.

#### 3c. Add the AuthProvider to the app layout

In `app/layout.tsx`:

```tsx
import { AuthProvider } from '@dream/auth';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>
          {children}
        </AuthProvider>
      </body>
    </html>
  );
}
```

#### 3d. Use the auth hook in components

```tsx
'use client';

import { useAuth } from '@dream/auth';

export function UserMenu() {
  const { user, isAuthenticated, isLoading, signOut, switchOrganization } = useAuth();

  if (isLoading) return <Skeleton />;
  if (!isAuthenticated) return null;

  return (
    <div>
      <span>{user.name} ({user.email})</span>
      <button onClick={() => signOut()}>Sign out</button>
    </div>
  );
}
```

The `useAuth()` hook provides:

| Field | Type | Description |
|---|---|---|
| `user` | `SessionUser \| null` | Current user identity, roles, permissions |
| `isAuthenticated` | `boolean` | Whether a valid session exists |
| `isLoading` | `boolean` | Whether auth state is being resolved |
| `signIn` | `(provider, options?) => Promise<void>` | Trigger sign-in flow |
| `signOut` | `() => Promise<void>` | End session |
| `switchOrganization` | `(orgId) => Promise<void>` | Switch active tenant |

---

### Step 4: @dream/multi-tenant -- Tenant Isolation

This package ensures every database query is automatically scoped to the correct organization. It replaces hardcoded `DEFAULT_ORG_ID` constants and manual `organizationId` filtering.

#### 4a. Create tenant configuration

Create `lib/tenant/config.ts`:

**Multi-tenant mode** (Dream Team, Dream Payroll, Dream Books, Dream Learn):

```typescript
import { createTenantConfig } from '@dream/multi-tenant';

export const tenantConfig = createTenantConfig({
  mode: 'multi',

  // Priority order: session first, then subdomain, then header
  extractionSources: ['session', 'subdomain', 'header'],

  subdomainConfig: {
    baseDomain: 'dreamteam.app',
    excludeSubdomains: ['www', 'api', 'admin', 'auth', 'mail', 'cdn', 'static'],
  },

  headerName: 'X-Tenant-ID',  // For programmatic API clients

  // Enforce tenant status checks (active/suspended/archived)
  statusEnforcement: true,
});
```

**Single-tenant mode** (HireWise):

```typescript
import { createTenantConfig } from '@dream/multi-tenant';

export const tenantConfig = createTenantConfig({
  mode: 'single',
  singleTenantId: process.env.TENANT_ID!,
});
```

Same APIs, same hooks, same types. The only difference is configuration. If HireWise ever needs multi-tenancy, change one line.

#### 4b. Add the TenantProvider to the app layout

In `app/layout.tsx` (add below AuthProvider):

```tsx
import { AuthProvider } from '@dream/auth';
import { TenantProvider } from '@dream/multi-tenant';
import { tenantConfig } from '@/lib/tenant/config';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>
          <TenantProvider config={tenantConfig}>
            {children}
          </TenantProvider>
        </AuthProvider>
      </body>
    </html>
  );
}
```

#### 4c. Use the tenant hook in components

```tsx
'use client';

import { useTenant } from '@dream/multi-tenant';

export function OrganizationSwitcher() {
  const { tenantId, organization, organizations, switchOrganization, isLoading } = useTenant();

  if (isLoading) return <Skeleton />;

  return (
    <select
      value={tenantId ?? ''}
      onChange={(e) => switchOrganization(e.target.value)}
    >
      {organizations.map((org) => (
        <option key={org.id} value={org.id}>
          {org.name}
        </option>
      ))}
    </select>
  );
}
```

The `useTenant()` hook provides:

| Field | Type | Description |
|---|---|---|
| `tenantId` | `string \| null` | Current organization ID |
| `organization` | `Organization \| null` | Full organization object (name, slug, plan, branding) |
| `isLoading` | `boolean` | Whether tenant context is being resolved |
| `switchOrganization` | `(orgId) => Promise<void>` | Switch to a different organization |
| `organizations` | `Organization[]` | All organizations the user belongs to |

---

### Step 5: @dream/rbac -- Role-Based Access Control

This package provides a unified permission model with typed constants, middleware, React gates, and hooks. It replaces inline role string comparisons, custom `hasPermission` utilities, and manual hierarchy checks.

#### 5a. Define product-specific permissions and roles

Create `lib/rbac/config.ts`:

```typescript
import { defineCustomRoles, PERMISSIONS } from '@dream/rbac';

// Built-in roles are available automatically:
//   super_admin (level 0), admin (level 10), manager (level 20),
//   user (level 30), guest (level 40)

// Define product-specific custom roles
export const customRoles = defineCustomRoles([
  {
    slug: 'hr_admin',
    name: 'HR Administrator',
    hierarchyLevel: 15,  // Between admin (10) and manager (20)
    permissions: [
      PERMISSIONS.USERS.WILDCARD,      // 'users:*'
      PERMISSIONS.TEAMS.WILDCARD,      // 'teams:*'
      PERMISSIONS.ROLES.READ,          // 'roles:read'
      PERMISSIONS.ROLES.ASSIGN,        // 'roles:assign'
      'employees:*',                   // Product-specific permission
      'payroll:read',
    ],
  },
  {
    slug: 'accountant',
    name: 'Accountant',
    hierarchyLevel: 22,  // Between manager (20) and user (30)
    permissions: [
      PERMISSIONS.INVOICES.WILDCARD,   // 'invoices:*'
      PERMISSIONS.REPORTS.WILDCARD,    // 'reports:*'
      'ledger:read',
      'ledger:write',
      'gst:read',
      'gst:file',
    ],
  },
]);

// Product-specific permission strings (extend the typed constants)
export const PRODUCT_PERMISSIONS = {
  EMPLOYEES: {
    READ: 'employees:read',
    WRITE: 'employees:write',
    READ_SELF: 'employees:read:self',
    WILDCARD: 'employees:*',
  },
  PAYROLL: {
    INITIATE: 'payroll:initiate',
    APPROVE: 'payroll:approve',
    READ: 'payroll:read',
  },
} as const;
```

#### 5b. Protect API routes with permission middleware

```typescript
import { requirePermission, requireAnyPermission, requireMinimumRoleMiddleware } from '@dream/rbac';

// Single permission required
export const GET = requirePermission('invoices:read')(
  async (req) => {
    // Only executes if user has invoices:read
    const invoices = await db.invoices.list(req.tenantId);
    return Response.json({ success: true, data: invoices });
  }
);

// Any of these permissions grants access (OR logic)
export const POST = requireAnyPermission('invoices:write', 'invoices:*')(
  async (req) => {
    // Executes if user has invoices:write OR invoices:*
  }
);

// Minimum role level (admin or above)
export const DELETE = requireMinimumRoleMiddleware(10)(
  async (req) => {
    // Only admin (10) and super_admin (0) can reach this
  }
);
```

#### 5c. Use React permission gates in components

```tsx
import { PermissionGate, RoleGate, AdminGate } from '@dream/rbac';

export function InvoicePage({ invoice }: { invoice: Invoice }) {
  return (
    <div>
      {/* Everyone with invoices:read sees the details */}
      <InvoiceDetails invoice={invoice} />

      {/* Only users with invoices:write see the edit button */}
      <PermissionGate permission="invoices:write">
        <EditButton invoiceId={invoice.id} />
      </PermissionGate>

      {/* Only users with invoices:delete see the delete button */}
      <PermissionGate
        permission="invoices:delete"
        fallback={<span className="text-muted">Contact admin to delete</span>}
      >
        <DeleteButton invoiceId={invoice.id} />
      </PermissionGate>

      {/* Only admins see the audit history */}
      <AdminGate>
        <AuditHistory resourceId={invoice.id} />
      </AdminGate>
    </div>
  );
}
```

#### 5d. Use permission hooks for conditional logic

```tsx
'use client';

import { usePermission, useRole, useHasMinimumRole } from '@dream/rbac';

export function InvoiceActions({ invoice }: { invoice: Invoice }) {
  const canEdit = usePermission('invoices:write');
  const canDelete = usePermission('invoices:delete');
  const canExport = usePermission('reports:export');
  const isAdmin = useHasMinimumRole('admin');
  const { role, roles, hierarchyLevel } = useRole();

  return (
    <div className="flex gap-2">
      {canEdit && <EditButton invoiceId={invoice.id} />}
      {canDelete && <DeleteButton invoiceId={invoice.id} />}
      {canExport && <ExportButton invoiceId={invoice.id} />}
      {isAdmin && <TransferOwnerButton invoiceId={invoice.id} />}
    </div>
  );
}
```

---

## 3. createApiHandler -- Everything Together

This is where all 5 packages converge. The `createApiHandler` from `@dream/errors` wraps authentication, permission checking, tenant extraction, input validation, audit event emission, and error formatting in a single function. You write only the business logic.

### Before (manual boilerplate -- 25+ lines per route)

This is what a typical route looks like today in 4 of 5 products:

```typescript
// BEFORE: Dream Books style (no auth, no RBAC, no tenant, no error handling)
export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  try {
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const orgId = session.user.organizationId;
    if (!orgId) {
      return NextResponse.json({ error: 'No organization' }, { status: 400 });
    }

    // Check permissions manually...
    if (session.user.role !== 'admin' && session.user.role !== 'hr_admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    const body = await request.json();
    // Manual validation...
    if (!body.name || typeof body.name !== 'string') {
      return NextResponse.json({ error: 'Name is required' }, { status: 400 });
    }

    const user = await db.users.update(orgId, params.id, body);
    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    return NextResponse.json({ data: user });
  } catch (error) {
    console.error('Failed to update user:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

### After (createApiHandler -- business logic only)

```typescript
import { createApiHandler, NotFoundError } from '@dream/errors';
import { z } from 'zod';

const updateUserSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email().optional(),
  phone: z.string().optional(),
});

export const PUT = createApiHandler(
  async (req, ctx) => {
    const body = updateUserSchema.parse(await req.json());

    const user = await db.users.update(ctx.tenantId, ctx.params.id, body);
    if (!user) {
      throw new NotFoundError({
        code: 'users/not-found',
        message: `User ${ctx.params.id} not found in tenant ${ctx.tenantId}`,
        userMessage: 'The requested user could not be found.',
      });
    }

    return user;
    // Audit event { action: 'user.updated', resourceId: ctx.params.id } emitted automatically
  },
  {
    requireAuth: true,
    requiredPermissions: ['users:write'],
    auditAction: 'user.updated',
  }
);
```

### What createApiHandler does automatically

| Concern | What Happens | If It Fails |
|---|---|---|
| **Authentication** | Validates session exists and is active | Returns `401` with `auth/unauthenticated` |
| **Tenant extraction** | Resolves `tenantId` from session/subdomain/header | Returns `400` with `tenant/not-found` |
| **Tenant status** | Checks organization is `active` | Returns `403` with `tenant/suspended` or `tenant/archived` |
| **Permission check** | Verifies user has `requiredPermissions` | Returns `403` with `rbac/permission-denied` |
| **Request ID** | Generates `crypto.randomUUID()`, adds to response headers | Always succeeds |
| **Business logic** | Executes your handler function | Catches errors (see below) |
| **Error formatting** | Converts `PlatformError` subclasses to standard JSON | Maps Zod errors to `ValidationError` |
| **Audit emission** | Emits audit event asynchronously if `auditAction` is set | Buffered for guaranteed delivery |
| **Response formatting** | Wraps return value in `{ success: true, data: T }` | N/A |

### Handler options reference

```typescript
interface ApiHandlerOptions {
  requireAuth?: boolean;            // default: true
  requiredPermissions?: string[];   // e.g., ['users:write']
  requiredRole?: string;            // e.g., 'admin'
  minimumRoleLevel?: number;        // e.g., 20 (manager or above)
  validationSchema?: ZodSchema;     // auto-validate request body
  auditAction?: string;             // e.g., 'user.updated'
}
```

### More handler examples

**List with pagination:**

```typescript
export const GET = createApiHandler(
  async (req, ctx) => {
    const url = new URL(req.url);
    const page = parseInt(url.searchParams.get('page') ?? '1');
    const pageSize = parseInt(url.searchParams.get('pageSize') ?? '20');

    const { data, total } = await db.invoices.list(ctx.tenantId, { page, pageSize });

    return { data, pagination: { page, pageSize, totalItems: total } };
  },
  { requiredPermissions: ['invoices:read'] }
);
```

**Create with Zod validation:**

```typescript
const createInvoiceSchema = z.object({
  customerId: z.string().uuid(),
  lineItems: z.array(z.object({
    description: z.string(),
    quantity: z.number().positive(),
    unitPrice: z.number().nonnegative(),
  })).min(1),
  dueDate: z.string().datetime(),
});

export const POST = createApiHandler(
  async (req, ctx) => {
    const body = createInvoiceSchema.parse(await req.json());
    const invoice = await db.invoices.create(ctx.tenantId, ctx.user.userId, body);
    return invoice;
  },
  {
    requiredPermissions: ['invoices:write'],
    auditAction: 'invoice.created',
  }
);
```

**Delete with resource lookup:**

```typescript
export const DELETE = createApiHandler(
  async (req, ctx) => {
    const invoice = await db.invoices.get(ctx.tenantId, ctx.params.id);
    if (!invoice) {
      throw new NotFoundError({
        code: 'invoices/not-found',
        message: `Invoice ${ctx.params.id} not found`,
        userMessage: 'Invoice not found.',
      });
    }

    await db.invoices.delete(ctx.tenantId, ctx.params.id);
    return { deleted: true };
  },
  {
    requiredPermissions: ['invoices:delete'],
    auditAction: 'invoice.deleted',
  }
);
```

**Public route (no auth):**

```typescript
export const GET = createApiHandler(
  async (req) => {
    return { status: 'healthy', timestamp: new Date().toISOString() };
  },
  { requireAuth: false }
);
```

---

## 4. Per-Product Configuration Examples

Each product configures the foundation differently based on its needs. Below are the minimal configurations.

### Dream Team

Full multi-tenant with Azure SSO and 4 custom roles.

```typescript
// lib/auth/config.ts
import { createAuthConfig } from '@dream/auth';

export const authConfig = createAuthConfig({
  providers: ['credentials', 'azure-entra'],
  azure: {
    clientId: process.env.AZURE_AD_CLIENT_ID!,
    clientSecret: process.env.AZURE_AD_CLIENT_SECRET!,
    tenantId: process.env.AZURE_AD_TENANT_ID!,
  },
  lockout: { maxAttempts: 5, durationMinutes: 15 },
  publicRoutes: ['/auth/signin', '/auth/error', '/api/health'],
});

// lib/tenant/config.ts
import { createTenantConfig } from '@dream/multi-tenant';

export const tenantConfig = createTenantConfig({
  mode: 'multi',
  extractionSources: ['session', 'subdomain', 'header'],
  subdomainConfig: {
    baseDomain: 'dreamteam.app',
  },
});

// lib/rbac/config.ts
import { defineCustomRoles, PERMISSIONS } from '@dream/rbac';

export const customRoles = defineCustomRoles([
  {
    slug: 'hr_admin',
    name: 'HR Administrator',
    hierarchyLevel: 15,
    permissions: [PERMISSIONS.USERS.WILDCARD, PERMISSIONS.TEAMS.WILDCARD, PERMISSIONS.ROLES.ASSIGN, 'employees:*'],
  },
  {
    slug: 'employee',
    name: 'Employee',
    hierarchyLevel: 30,
    permissions: [PERMISSIONS.USERS.READ, PERMISSIONS.TEAMS.READ, 'employees:read:self', 'leaves:read:self', 'leaves:write:self'],
  },
]);
```

**Migration notes**: Remove `DEFAULT_TENANT_ID` constant. Replace `withPermission()` calls with `requirePermission()`. Remove manual auth boilerplate from 66 API route directories.

---

### Dream Payroll

Session-based tenancy with Azure + Google SSO and hybrid roles.

```typescript
// lib/auth/config.ts
import { createAuthConfig } from '@dream/auth';

export const authConfig = createAuthConfig({
  providers: ['credentials', 'azure-entra', 'google'],
  azure: {
    clientId: process.env.AZURE_AD_CLIENT_ID!,
    clientSecret: process.env.AZURE_AD_CLIENT_SECRET!,
    tenantId: process.env.AZURE_AD_TENANT_ID!,
  },
  google: {
    clientId: process.env.GOOGLE_CLIENT_ID!,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
  },
  lockout: { maxAttempts: 5, durationMinutes: 15 },
  publicRoutes: ['/auth/signin', '/auth/suspended', '/api/health'],
});

// lib/tenant/config.ts
import { createTenantConfig } from '@dream/multi-tenant';

export const tenantConfig = createTenantConfig({
  mode: 'multi',
  extractionSources: ['session'],  // Session-only extraction (current behavior)
  statusEnforcement: true,         // Already implemented in Payroll -- now standardized
});

// lib/rbac/config.ts
import { defineCustomRoles } from '@dream/rbac';

export const customRoles = defineCustomRoles([
  { slug: 'hr_admin', name: 'HR Admin', hierarchyLevel: 15, permissions: ['employee:*', 'salary:read', 'payroll:read', 'compliance:read'] },
  { slug: 'payroll_admin', name: 'Payroll Admin', hierarchyLevel: 15, permissions: ['employee:read', 'salary:*', 'payroll:*'] },
  { slug: 'finance', name: 'Finance', hierarchyLevel: 18, permissions: ['payroll:approve', 'disbursement:*', 'reports:*'] },
  { slug: 'compliance_officer', name: 'Compliance Officer', hierarchyLevel: 20, permissions: ['compliance:*', 'audit:read'] },
  { slug: 'employee', name: 'Employee', hierarchyLevel: 30, permissions: ['employee:read:self', 'salary:read:self', 'payslip:read:self', 'leaves:read:self'] },
]);
```

**Migration notes**: Dream Payroll already has `createApiHandler`. Replace the local implementation with the foundation version. The API surface is identical. Replace `rolePermissions` static map with `defineCustomRoles`. Remove separate admin JWT handling.

---

### Dream Books

Adding auth, RBAC, and tenancy from scratch. This is the largest migration.

```typescript
// lib/auth/config.ts
import { createAuthConfig } from '@dream/auth';

export const authConfig = createAuthConfig({
  providers: ['credentials'],  // Start with credentials, add SSO later
  lockout: { maxAttempts: 5, durationMinutes: 15 },
  publicRoutes: ['/auth/signin', '/auth/signup', '/api/health'],
});

// lib/tenant/config.ts
import { createTenantConfig } from '@dream/multi-tenant';

export const tenantConfig = createTenantConfig({
  mode: 'multi',
  extractionSources: ['session'],
  statusEnforcement: true,
});

// lib/rbac/config.ts
import { defineCustomRoles, PERMISSIONS } from '@dream/rbac';

export const customRoles = defineCustomRoles([
  { slug: 'accountant', name: 'Accountant', hierarchyLevel: 22, permissions: [PERMISSIONS.INVOICES.WILDCARD, PERMISSIONS.REPORTS.WILDCARD, 'ledger:*', 'gst:*', 'banking:read'] },
  { slug: 'bookkeeper', name: 'Bookkeeper', hierarchyLevel: 25, permissions: [PERMISSIONS.INVOICES.READ, PERMISSIONS.INVOICES.WRITE, 'ledger:read', 'ledger:write', 'banking:read'] },
  { slug: 'viewer', name: 'Viewer', hierarchyLevel: 35, permissions: [PERMISSIONS.INVOICES.READ, PERMISSIONS.REPORTS.READ, 'ledger:read'] },
]);
```

**Migration notes**: This product has 42 files with 190 occurrences of `DEFAULT_ORG_ID = '00000000-0000-0000-0000-000000000001'`. Every one must be replaced with `ctx.tenantId` from `createApiHandler`. Every raw route handler must be wrapped in `createApiHandler`. This is the critical security fix.

---

### HireWise

Single-tenant, credentials only, 6 custom roles mapped to hierarchy.

```typescript
// lib/auth/config.ts
import { createAuthConfig } from '@dream/auth';

export const authConfig = createAuthConfig({
  providers: ['credentials'],
  // Session duration reduced from 30 days to 8 hours (security fix)
  sessionMaxAge: 28800,
  lockout: { maxAttempts: 5, durationMinutes: 15 },
  publicRoutes: ['/auth/signin', '/api/health'],
});

// lib/tenant/config.ts
import { createTenantConfig } from '@dream/multi-tenant';

export const tenantConfig = createTenantConfig({
  mode: 'single',
  singleTenantId: process.env.TENANT_ID!,
});

// lib/rbac/config.ts
import { defineCustomRoles } from '@dream/rbac';

// Maps HireWise's 6 SCREAMING_CASE roles to the foundation hierarchy
export const customRoles = defineCustomRoles([
  { slug: 'technical_expert', name: 'Technical Expert', hierarchyLevel: 18, permissions: ['tests:read', 'tests:write', 'questions:*', 'evaluations:*'] },
  { slug: 'recruiter', name: 'Recruiter', hierarchyLevel: 20, permissions: ['candidates:*', 'tests:read', 'tests:assign', 'invitations:*', 'evaluations:read'] },
  { slug: 'interviewer', name: 'Interviewer', hierarchyLevel: 25, permissions: ['candidates:read', 'evaluations:read', 'evaluations:write', 'interviews:*'] },
  { slug: 'proctor_reviewer', name: 'Proctor Reviewer', hierarchyLevel: 25, permissions: ['tests:read', 'proctoring:*', 'evaluations:read'] },
  { slug: 'candidate', name: 'Candidate', hierarchyLevel: 35, permissions: ['tests:read:self', 'results:read:self', 'profile:read:self', 'profile:write:self'] },
]);
```

**Migration notes**: Replace the `Role` type duplicated in 3 files (`auth.ts`, `auth.config.ts`, `middleware.ts`) with foundation role slugs. Replace 184 inline `session.user.role !== "ADMIN"` checks across 104 files with `requirePermission()` or `PermissionGate`. Reduce session TTL from 30 days to 8 hours.

---

## 5. Testing

### Mock auth in unit tests

```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';

// Mock the auth hook
vi.mock('@dream/auth', () => ({
  useAuth: () => ({
    user: {
      userId: 'usr_test123',
      email: 'test@example.com',
      name: 'Test User',
    },
    isAuthenticated: true,
    isLoading: false,
    signIn: vi.fn(),
    signOut: vi.fn(),
    switchOrganization: vi.fn(),
  }),
  AuthProvider: ({ children }: { children: React.ReactNode }) => <>{children}</>,
}));
```

### Mock tenant context

```typescript
vi.mock('@dream/multi-tenant', () => ({
  useTenant: () => ({
    tenantId: 'tnt_test456',
    organization: {
      id: 'tnt_test456',
      name: 'Test Corp',
      slug: 'test-corp',
      status: 'active',
    },
    organizations: [],
    isLoading: false,
    switchOrganization: vi.fn(),
  }),
  TenantProvider: ({ children }: { children: React.ReactNode }) => <>{children}</>,
}));
```

### Test permission gate rendering

```typescript
import { PermissionGate } from '@dream/rbac';

vi.mock('@dream/rbac', async () => {
  const actual = await vi.importActual('@dream/rbac');
  return {
    ...actual,
    usePermission: (permission: string) => {
      // Grant invoices:read but deny invoices:delete
      const granted = ['invoices:read', 'invoices:write'];
      return granted.includes(permission);
    },
  };
});

describe('InvoicePage', () => {
  it('shows edit button for users with invoices:write', () => {
    render(<InvoicePage invoice={mockInvoice} />);
    expect(screen.getByText('Edit')).toBeInTheDocument();
  });

  it('hides delete button for users without invoices:delete', () => {
    render(<InvoicePage invoice={mockInvoice} />);
    expect(screen.queryByText('Delete')).not.toBeInTheDocument();
  });
});
```

### Test createApiHandler routes

```typescript
import { describe, it, expect } from 'vitest';

describe('PUT /api/users/[id]', () => {
  it('returns 401 for unauthenticated requests', async () => {
    const req = new Request('http://localhost/api/users/usr_123', {
      method: 'PUT',
      body: JSON.stringify({ name: 'Updated Name' }),
    });

    // No session cookie attached
    const res = await PUT(req, { params: Promise.resolve({ id: 'usr_123' }) });
    const body = await res.json();

    expect(res.status).toBe(401);
    expect(body.success).toBe(false);
    expect(body.error.code).toBe('auth/unauthenticated');
  });

  it('returns 403 for users without users:write permission', async () => {
    // Attach session with only users:read permission
    const req = createAuthenticatedRequest('PUT', '/api/users/usr_123', {
      body: { name: 'Updated Name' },
      permissions: ['users:read'],  // Missing users:write
    });

    const res = await PUT(req, { params: Promise.resolve({ id: 'usr_123' }) });
    const body = await res.json();

    expect(res.status).toBe(403);
    expect(body.error.code).toBe('rbac/permission-denied');
  });

  it('returns 404 when user does not exist', async () => {
    const req = createAuthenticatedRequest('PUT', '/api/users/usr_nonexistent', {
      body: { name: 'Updated Name' },
      permissions: ['users:write'],
    });

    const res = await PUT(req, { params: Promise.resolve({ id: 'usr_nonexistent' }) });
    const body = await res.json();

    expect(res.status).toBe(404);
    expect(body.error.code).toBe('users/not-found');
    expect(body.error.requestId).toBeDefined();
  });

  it('updates user and returns standardized response', async () => {
    const req = createAuthenticatedRequest('PUT', '/api/users/usr_123', {
      body: { name: 'Updated Name' },
      permissions: ['users:write'],
    });

    const res = await PUT(req, { params: Promise.resolve({ id: 'usr_123' }) });
    const body = await res.json();

    expect(res.status).toBe(200);
    expect(body.success).toBe(true);
    expect(body.data.name).toBe('Updated Name');
  });
});
```

---

## 6. Migration Checklist

Use this checklist to track your product's adoption of the foundation packages. The order matches the integration steps above.

### Install and configure

- [ ] Install all 5 packages: `npm install @dream/types @dream/auth @dream/rbac @dream/multi-tenant @dream/errors`
- [ ] Create `lib/auth/config.ts` with `createAuthConfig()`
- [ ] Create `lib/tenant/config.ts` with `createTenantConfig()`
- [ ] Create `lib/rbac/config.ts` with `defineCustomRoles()`

### Replace custom auth

- [ ] Replace custom `auth.ts` / `auth.config.ts` with `createAuthConfig()`
- [ ] Replace custom `middleware.ts` with `createAuthMiddleware(authConfig)`
- [ ] Wrap app layout in `<AuthProvider>`
- [ ] Replace custom auth hooks/context with `useAuth()`
- [ ] Verify session duration is 8 hours (not 30 days)
- [ ] Verify account lockout is active (5 attempts, 15 minutes)

### Replace custom tenant handling

- [ ] Replace hardcoded `DEFAULT_ORG_ID` / `DEFAULT_TENANT_ID` constants with `ctx.tenantId`
- [ ] Replace manual `organizationId` extraction with tenant config
- [ ] Wrap app layout in `<TenantProvider config={tenantConfig}>`
- [ ] Replace custom org hooks/context with `useTenant()`

### Replace custom authorization

- [ ] Map existing roles to foundation hierarchy (built-in + custom via `defineCustomRoles`)
- [ ] Replace inline role string checks (e.g., `role !== "ADMIN"`) with `requirePermission()`
- [ ] Replace custom `hasPermission()` / `withPermission()` utilities with `@dream/rbac` exports
- [ ] Add `<PermissionGate>` components to replace conditional renders based on role strings
- [ ] Replace custom permission hooks with `usePermission()` and `useRole()`

### Replace custom error handling

- [ ] Replace manual try-catch blocks with `createApiHandler()`
- [ ] Replace custom error objects/strings with `PlatformError` subclasses
- [ ] Replace ad-hoc `NextResponse.json({ error: "..." })` with typed error throws
- [ ] Verify all API routes return the standardized error format: `{ success, error: { code, message, userMessage, requestId } }`

### Replace custom types

- [ ] Replace local `User`, `Organization`, `Role` interfaces with `@dream/types` imports
- [ ] Replace local `ApiResponse`, error shape types with `@dream/types` response types
- [ ] Replace local Zod schemas for core entities with `@dream/types/schemas`
- [ ] Replace local ORM schema definitions for platform entities with `@dream/types/drizzle` or `@dream/types/prisma`

### Verify

- [ ] Run full test suite -- all existing tests still pass
- [ ] Verify no route is accessible without authentication (except explicit public routes)
- [ ] Verify no route returns data from a different tenant
- [ ] Verify error responses follow the standard format across all routes
- [ ] Verify audit events are emitted for all create/update/delete operations
- [ ] Remove all dead code: old auth configs, old middleware, old error utilities, hardcoded tenant IDs
